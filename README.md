# 进度
用 C 编写的一个符合 Limine 标准的小型 x86-64 内核，并使用 Limine 引导加载程序启动

- Limine 本质只是引导程序（bootloader），它的工作是：
    - 加载你的内核 ELF 文件（bin/sudoOS）
    - 切换到你指定的 CPU 状态（x86_64 long mode）
    - 为你准备好一些必要的信息（内存地图、帧缓冲、SMBIOS...）
    - 跳转到你的内核入口函数 kmain()

- 内核地址空间：0xffffffff80000000 ~ 0xffffffffffffffff


# 内存管理系统

## 内存布局

```
================================================================================
                  阶段 1: Limine 引导交接后 (Limine Page Tables)
================================================================================

      [ 虚拟地址空间 (Virtual Address Space) ]           [ 物理地址空间 (Physical Address Space) ]
      (64-bit Address Space, Canonical Form)

 0xFFFFFFFFFFFFFFFF +----------------------+             +----------------------+ <--- Max RAM
                    |                      |             |                      |
                    |   Kernel Image Map   |  mapped to  |     可用 RAM (Free)  |
 Kernel Virtual Base| (.text, .data, ...)  | ----------> |----------------------|
 (e.g. 0xFFFFFFFF8..+----------------------+             |   Limine Reclaimable |
                    |                      |             | (Memmap, Stack, etc) |
                    |                      |             |----------------------|
                    |                      |             |                      |
                    |         ...          |             |   Kernel Image Phys  | <--- Kernel Phys Base
                    |                      |             | (.text, .data, ...)  |
                    |                      |             |----------------------|
                    |                      |             |                      |
                    |                      |             |     可用 RAM (Free)  |
                    +----------------------+             |                      |
                    |                      |             +----------------------+ 0x00000000
                    |    HHDM (Limine)     |  mapped to
    HHDM Start      | All Physical Memory  | ----------> [覆盖整个物理内存 0 - Max]
 (e.g. 0xFFFF8......+----------------------+

                    |                      |
           0x00...  +----------------------+
                    | (可能包含 1:1 映射)  |
                    | (Limine 可能会映射   |
                    |  前 4GB，但不保证)   |
                    +----------------------+
```

```
================================================================================
               阶段 2: kmain 初始化后 (SudoOS Custom Page Tables)
================================================================================

      [ 虚拟地址空间 (Virtual Address Space) ]           [ 物理地址空间 (Physical Address Space) ]
                                                               (由 PMM 管理)

 0xFFFFFFFFFFFFFFFF +----------------------+             +----------------------+ <--- Max RAM
                    |                      |             |                      |
                    |   Kernel Image Map   |  mapped to  |     可用 RAM (Free)  |
 Kernel Virtual Base| (RWX 权限重设/分离)  | ----------> |----------------------|
 (e.g. 0xFFFFFFFF8..+----------------------+             |      PMM Bitmap      | <--- pmm_init 分配
                    |                      |             | (管理所有页面的状态) |
                    |                      |             |----------------------|
                    |                      |             |     可用 RAM (Free)  |
                    |         ...          |             |----------------------|
                    |                      |             |  Kernel PML4 (New)   | <--- paging_init 分配
                    |                      |             |  (及 PDPT, PD 等)    |
                    |                      |             |----------------------|
                    |                      |             |   Limine Reclaimable |
                    +----------------------+             | (此时数据可能仍存在) |
                    |                      |             |----------------------|
                    |     HHDM (SudoOS)    |  mapped to  |   Kernel Image Phys  |
    HHDM Start      | All Physical Memory  | ----------> | (.text, .data, ...)  |
 (e.g. 0xFFFF8......| (重映射，用于内核访问|             |----------------------|
                    |  任意物理地址)       |             |                      |
                    +----------------------+             |     可用 RAM (Free)  |
                    |                      |             |                      |
                    | (Limine 的旧映射被   |             | (0号页通常保留/Busy) |
                    |  丢弃，低地址空间    |             +----------------------+ 0x00000000
                    |  目前为空/User Space)|
           0x00...  +----------------------+
```


## 初始化内存管理系统

- 读取memmap（物理内存探测），检测物理内存的情况
- memmap结构
```c
struct limine_memmap_response {
    uint64_t entry_count;             // 条目数量
    struct limine_memmap_entry **entries; // 指向 entries[] 数组
};

struct limine_memmap_entry {
    uint64_t base;    // 物理地址起点
    uint64_t length;  // 长度
    uint64_t type;    // 区域类型
};

```
- 物理内存的类型
```c
LIMINE_MEMMAP_USABLE               // 可以用来分配给物理内存管理
LIMINE_MEMMAP_RESERVED             // 不可用（可能被固件、BIOS 占用）
LIMINE_MEMMAP_ACPI_RECLAIMABLE     // ACPI 信息区，可在解析 ACPI 后使用
LIMINE_MEMMAP_ACPI_NVS             // ACPI NVS（不可动）
LIMINE_MEMMAP_BOOTLOADER_RECLAIMABLE
LIMINE_MEMMAP_KERNEL_AND_MODULES   // 内核自身所在内存
LIMINE_MEMMAP_FRAMEBUFFER          // 显存
```

## 物理页框管理-Bitmap

- 建立过程
    - 获取物理地址最高位。
    - 计算将物理地址空间总共分成多少页，从而计算Bitmap大小。
    - 遍历mmap，找到一个空闲区域放置
    - 通过pa+hhdm获取bitmap的虚拟地址，并初始化
    - 再次遍历mmap，这次对每一个空闲区域进行分页并设置

- Bitmap每一项为`uint8_t`类型，8位无符号整数的每一位对应一个物理页框，总共对应8个物理页框，共`8*4kB` 大小。
- Bitmap的i位对应物理地址`i*PAGE_SIZE`
- 对Bitmap的bit位进行操作：
```c
static inline void bit_set(size_t bit);

static inline void bit_unset(size_t bit);

static inline bool bit_test(size_t bit);
```

- 内存分配接口
```c
// 分配一页
uint64_t pmm_alloc_page();
// 释放一页
void pmm_free_page(uint64_t pa);
```

## 内核地址空间分区

### 1. 内核虚拟地址空间布局图 

```text
虚拟地址 (Virtual Address)             内存区域 (Memory Region)              作用与存放内容
+----------------------------+-----------------------------------+------------------------------------------+
| 0xFFFFFFFF81000000 (或更高) |      内核栈区 (Kernel Stacks)      | 存放各进程/线程的内核态运行栈 (kmalloc 分配) |
+----------------------------+-----------------------------------+------------------------------------------+
| 0xFFFFFFFF80000000         |     内核镜像区 (Kernel Image)      | 存放 .text, .rodata, .data, .bss (IDT)   |
+----------------------------+-----------------------------------+------------------------------------------+
|            ...             |              未使用               | 预留空间                                 |
+----------------------------+-----------------------------------+------------------------------------------+
| 0xFFFFB00000000000         |      MMIO / Vmalloc 映射区        | 映射硬件寄存器或不连续物理内存           |
+----------------------------+-----------------------------------+------------------------------------------+
| 0xFFFF900000000000         |      内核堆区 (Kernel Heap)        | kmalloc 管理的区域，用于动态分配小对象   |
+----------------------------+-----------------------------------+------------------------------------------+
| 0xFFFF800000000000 (HHDM)  |   物理内存直接映射区 (HHDM Area)   | 直接访问所有物理内存 (如 Bitmap 数组)    |
+----------------------------+-----------------------------------+------------------------------------------+
|            ...             |            用户态空间             | 存放进程的用户代码、数据、栈 (Ring 3)    |
+----------------------------+-----------------------------------+------------------------------------------+

```

---

### 2. 各分区详细说明

#### **A. 物理内存直接映射区 (HHDM Area)**

* **起始地址：** `HHDM_OFFSET`（由 Limine 协议提供）。
* **存放内容：** 整个物理内存的副本。在您的设计中，**Bitmap 数组** 应该通过该区域访问。
* **作用：** 内核可以通过 `虚拟地址 = 物理地址 + HHDM_OFFSET` 的简单公式直接操作物理内存，无需反复建立新页表。这对 PMM 和页表项（PTE/PDE）本身的修改至关重要。

#### **B. 内核堆区 (Kernel Heap)**

* **起始地址：** 建议设为 `0xFFFF900000000000`（可根据需要调整）。
* **存放内容：** 存放内核运行期间动态申请的对象，如进程控制块 (PCB)、缓冲区、动态分配的数据结构。
* **作用：** 这是您新实现的 **`kmalloc`** 管理的主战场。通过双向循环链表，在此区域内进行细粒度的字节分配。当空间不足时，调用 `pmm_alloc_page` 申请页框并由 `vmm_map_page` 映射到此区域。

#### **C. MMIO / Vmalloc 映射区**

* **起始地址：** 建议设为 `0xFFFFA00000000000` 或 `0xFFFFB00000000000`。
* **存放内容：** 硬件寄存器映射（如显存 Framebuffer、APIC 寄存器）或不连续物理页组成的连续虚拟内存。
* **作用：** 提供一个逻辑上连续的窗口来访问硬件或零散内存。

#### **D. 内核镜像区 (Kernel Image)**

* **起始地址：** `0xFFFFFFFF80000000`（由链接脚本 `linker.lds` 定义）。
* **存放内容：**
* `.text`：内核代码。
* `.rodata`：只读常量。
* `.data` & `.bss`：全局变量。**IDT (中断描述符表)** 和 **GDT** 通常静态分配在这里。


* **作用：** 这是内核的“核心大本营”。`paging_init` 会根据 `kernel_addr_request` 的结果将链接好的 ELF 段映射到物理内存。

#### **E. 内核栈区 (Kernel Stacks)**

* **起始地址：** 紧跟在内核镜像之后，例如 `0xFFFFFFFF81000000`。
* **存放内容：** 每个进程独立的内核态栈。
* **作用：** 处理中断或系统调用时，CPU 切换到的临时工作空间。每个栈之间通常留一个不映射的“保护页”，防止一个进程的栈溢出后破坏另一个进程。

## 内核堆内存管理

这是一份基于您提供的源代码（`mm/pmm.c`, `mm/pmm.h` 等）编写的内核堆管理器技术文档。


### 内存布局与配置

堆管理器定义了以下关键的内存布局参数，位于 `src/mm/pmm.h` 中：

* **基地址 (`KERNEL_HEAP_BASE`)**: `0xFFFF900000000000`。这是堆在虚拟地址空间中的起始位置。
* **页大小 (`PAGE_SIZE`)**: `4096` 字节。
* **对齐方式**: 所有分配的内存大小均向上对齐到 **8字节**。
* **最小切割阈值 (`MIN_SPLIT`)**: `16` 字节。当空闲块剩余空间小于此值时，不再进行切割，以减少碎片。

### 核心数据结构

堆内存管理基于**双向循环链表**，链表中包含**所有**内存块（包括已分配和空闲的）。每个内存块由一个头部结构 `kheap_pghdr_t` 描述。

#### 内存块头 (`kheap_pghdr_t`)

定义于 `src/mm/pmm.h`：

```c
typedef struct {
    list_node_t node;   // 链表节点 (prev, next)，用于连接前后物理相邻的内存块
    uint64_t size;      // 数据区大小 (不包含头部本身的大小)
    bool is_free;       // 状态标志：true=空闲, false=已占用
} kheap_pghdr_t;

```

* **`HEADER_SIZE`**: `sizeof(kheap_pghdr_t)`，即每个内存块的固有开销。
* **链表组织**: 所有内存块按照虚拟地址顺序链接在全局链表 `kheap_list` 中。这使得 `kfree` 可以通过检查 `node.prev` 和 `node.next` 快速找到物理上相邻的块进行合并。


### 内存分配 (`kmalloc`)

采用 **First-Fit (首次适应)** 算法：

1. **对齐**: 将请求大小 `size` 向上对齐至 8 字节。
2. **搜索**: 遍历 `kheap_list`，寻找第一个满足 `is_free == true` 且 `size >= request_size` 的块。
3. **扩容**: 如果遍历结束仍未找到合适的块，则计算所需页数并调用 `kheap_expand` 扩容堆空间，随后递归重试分配。
4. **切割 (Splitting)**: 如果找到的块大小远大于请求大小（剩余空间 `>= HEADER_SIZE + MIN_SPLIT`），则将该块分裂为两个块：
* 前半部分为已分配块。
* 后半部分为新的空闲块，并插入到链表中。

5. **标记**: 将目标块的 `is_free` 设为 `false` 并返回数据区指针。

### 内存释放 (`kfree`)

支持 **即时合并 (Immediate Coalescing)**：

1. **定位**: 根据传入指针回退 `HEADER_SIZE` 字节找到块头。
2. **标记**: 将块状态设为 `is_free = true`。
3. **向后合并**: 检查 `node.next`。如果下一个块存在且空闲，并且地址连续，则将其吞并（增加当前块大小，从链表移除下一个块）。
4. **向前合并**: 检查 `node.prev`。如果前一个块存在且空闲，并且地址连续，则将当前块并入前一个块。

### 堆扩容 (`kheap_expand`)

当堆空间不足时，自动向高地址扩展：

1. **物理分配**: 调用 `pmm_alloc_page` 申请新的物理页。
2. **虚拟映射**: 调用 `vmm_map_page` 将新页映射到 `kheap_top` 指向的虚拟地址，属性为 `PTE_PRESENT | PTE_RW`。
3. **初始化**: 在新页起始处构建 `kheap_pghdr_t`，初始状态设为 `is_free = 0` (占用)。
4. **链表插入**: 使用 `list_add_before` 将新块插入到 `kheap_list` 尾部。
5. **触发合并**: 调用 `kfree` 释放这个新块。利用 `kfree` 的合并逻辑，如果新页与之前的堆顶在物理/逻辑上连续，它们会自动合并成一个更大的空闲块。
6. **更新边界**: `kheap_top` 指针增加 `PAGE_SIZE`。

### API 接口说明

以下接口声明在 `src/mm/pmm.h` 中：

#### `void kheap_init(size_t init_pages)`

* **功能**: 初始化内核堆管理器。
* **参数**: `init_pages` - 初始预分配的物理页数量。
* **实现细节**: 初始化 `kheap_list` 哨兵节点，设定 `kheap_top` 为基地址，并调用 `kheap_expand` 进行初始扩容。

#### `void* kmalloc(size_t size)`

* **功能**: 申请内核堆内存。
* **参数**: `size` - 请求的字节数。
* **返回**: 成功返回指向数据区的指针，失败返回 `NULL`。
* **依赖**: `first_fit`, `kheap_expand`。

#### `void kfree(void* ptr)`

* **功能**: 释放堆内存。
* **参数**: `ptr` - 由 `kmalloc` 返回的指针。如果为 `NULL` 则直接返回。
* **注意**: 包含双重释放检查（虽然当前实现仅打印日志或直接返回，建议在调试模式下Panic）。



## 4级分页系统

- 将一个 48位 的虚拟地址（Virtual Address），切分成 4 段索引（每段 9 位）和 1 段偏移量（12 位）
- 虽然指针是 64 位的，但标准的 4 级分页只使用了低 48 位（这就是为什么说是 256TB 地址空间）。高 16 位必须进行符号扩展（Canonical Form，通常全是0或全是1）。

### 虚拟地址的结构
```
63          48 47     39 38     30 29     21 20     12 11         0
+-------------+---------+---------+---------+---------+------------+
| Sign Extend | PML4    | PDPT    | PD      | PT      | Offset     |
| (不可用)    | Index   | Index   | Index   | Index   |            |
+-------------+---------+---------+---------+---------+------------+
       |           |         |         |         |          |
    必须为全0      9 bits    9 bits    9 bits    9 bits     12 bits
    或全1        (0~511)   (0~511)   (0~511)   (0~511)    (0~4095)
```
### 各级页表结构
- 每一级页表都刚好占用 4KB（一个物理页），并且包含 512 个条目（Entries）。每个条目 8 字节（64位）。

- CR3 寄存器: 存储顶级页表（PML4）的物理基地址
```
CR3 Register (存放 PML4 物理地址)
            |
            v
  +----------------------+
  |     PML4 Table       |  <-- 1. 用虚拟地址 Bits 39-47 (PML4 Index)
  | (Page Map Level 4)   |         找到第 N 个条目 (PML4E)
  +----------------------+
            |
            | PML4E 中包含下一级表的物理地址
            v
  +----------------------+
  |     PDPT Table       |  <-- 2. 用虚拟地址 Bits 30-38 (PDPT Index)
  | (Page Dir Pointer)   |         找到第 N 个条目 (PDPTE)
  +----------------------+
            |
            | PDPTE 中包含下一级表的物理地址
            v
  +----------------------+
  |      PD Table        |  <-- 3. 用虚拟地址 Bits 21-29 (PD Index)
  |   (Page Directory)   |         找到第 N 个条目 (PDE)
  +----------------------+
            |
            | PDE 中包含下一级表的物理地址
            v
  +----------------------+
  |      PT Table        |  <-- 4. 用虚拟地址 Bits 12-20 (PT Index)
  |     (Page Table)     |         找到第 N 个条目 (PTE)
  +----------------------+
            |
            | PTE 中包含最终物理页框的基地址 (Frame Address)
            v
    +------------------+
    |  Physical Page   |
    |   (4KB Frame)    |
    +------------------+
            ^
            |
            +--- 5. 加上虚拟地址 Bits 0-11 (Offset) = 最终物理地址
```

### 页表项结构 (PTE Structure)
无论是 PML4E, PDPTE, PDE 还是 PTE，它们的结构在硬件上高度相似。 这是一个标准的 64位 页表项结构图：
```
63 (NX)   51           12 11   9 8 7 6 5 4 3 2 1 0
+-----------+------------+------+-+-+-+-+-+-+-+-+-+
| NX Bit    | Physical   | Avail|G|S|D|A|P|P|U|R|P|
| (No Exec) | Address    |      | |Z| | |C|W|/|/| |
|           | (Frame)    |      | | | | |D|T|S|W| |
+-----------+------------+------+-+-+-+-+-+-+-+-+-+
      |            |         |     | | | | | | | | +-> Present (1=存在)
      |            |         |     | | | | | | | +---> Read/Write (1=可写)
      |            |         |     | | | | | | +-----> User/Super (1=用户态)
      |            |         |     | | | | | +-------> Write Through
      |            |         |     | | | | +---------> Cache Disable
      |            |         |     | | | +-----------> Accessed (CPU自动置1)
      |            |         |     | | +-------------> Dirty (仅PT有效, 写入后置1)
      |            |         |     | +---------------> Page Size (1=2MB大页)
      |            |         |     +-----------------> Global (TLB刷新不清除)
      |            |         +-----------------------> Available (OS自定义使用)
      |            +---------------------------------> 下一级表的物理基地址 (4KB对齐)
      +----------------------------------------------> No Execute (1=禁止执行代码)
```


---
# 在qemu上运行

```bash
make run
```



